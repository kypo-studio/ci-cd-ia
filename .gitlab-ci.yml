# .gitlab-ci.yml

# Image de base
default:
  image: python:3.11-slim

# Stages de la pipeline
stages:
  - validation
  - test
  - build
  - release

# Variables globales
variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  IMAGE_NAME: $CI_REGISTRY_IMAGE
  IMAGE_TAG: $CI_COMMIT_SHORT_SHA

# Cache pour acc√©l√©rer les builds
cache:
  key:
    files:
      - requirements.txt
  paths:
    - .cache/pip
    - venv/

# ================================================================
# STAGE 1: VALIDATION (Qualit√©, S√©curit√©, Format)
# ================================================================

# Installation des d√©pendances (job r√©utilisable)
.install_dependencies: &install_dependencies
  before_script:
    - python -m venv venv
    - source venv/bin/activate
    - pip install --upgrade pip
    - pip install -r requirements.txt -r requirements-dev.txt

# V√©rification de la syntaxe Python
syntax_check:
  stage: validation
  <<: *install_dependencies
  script:
    - source venv/bin/activate
    - python -m py_compile app/*.py
    - echo "‚úÖ Syntax check passed"
  allow_failure: false

# V√©rification du format avec Black
code_format:
  stage: validation
  <<: *install_dependencies
  script:
    - source venv/bin/activate
    - black --check --diff app/ tests/
    - echo "‚úÖ Code formatting check passed"
  allow_failure: false

# Analyse de qualit√© avec Flake8
code_quality_flake8:
  stage: validation
  <<: *install_dependencies
  script:
    - source venv/bin/activate
    - flake8 app/ tests/ --max-line-length=120 --statistics
    - echo "‚úÖ Flake8 quality check passed"
  allow_failure: false

# Analyse de qualit√© avec Pylint
code_quality_pylint:
  stage: validation
  <<: *install_dependencies
  script:
    - source venv/bin/activate
    - pylint app/ --fail-under=7.0
    - echo "‚úÖ Pylint quality check passed"
  allow_failure: true
  artifacts:
    reports:
      codequality: pylint-report.json
    expire_in: 1 week

# Analyse de s√©curit√© avec Bandit
security_scan:
  stage: validation
  <<: *install_dependencies
  script:
    - source venv/bin/activate
    - bandit -r app/ -f json -o bandit-report.json
    - bandit -r app/ -ll
    - echo "‚úÖ Security scan completed"
  artifacts:
    reports:
      sast: bandit-report.json
    paths:
      - bandit-report.json
    expire_in: 1 week
  allow_failure: true

# D√©tection de vuln√©rabilit√©s dans les d√©pendances
dependency_scan:
  stage: validation
  <<: *install_dependencies
  script:
    - source venv/bin/activate
    - pip install safety
    - safety check --json > safety-report.json || true
    - safety check
    - echo "‚úÖ Dependency scan completed"
  artifacts:
    paths:
      - safety-report.json
    expire_in: 1 week
  allow_failure: true

# D√©tection de secrets avec GitLeaks
secrets_detection:
  stage: validation
  image: zricethezav/gitleaks:latest
  script:
    - gitleaks detect --verbose --no-git --source . --report-format json --report-path gitleaks-report.json
    - echo "‚úÖ No secrets detected"
  artifacts:
    paths:
      - gitleaks-report.json
    expire_in: 1 week
    when: on_failure
  allow_failure: false

# D√©tection de secrets avec TruffleHog (alternative)
trufflehog_scan:
  stage: validation
  image: trufflesecurity/trufflehog:latest
  script:
    - trufflehog filesystem . --json > trufflehog-report.json || true
    - echo "‚úÖ TruffleHog scan completed"
  artifacts:
    paths:
      - trufflehog-report.json
    expire_in: 1 week
  allow_failure: true

# ================================================================
# STAGE 2: TESTS (Unit + E2E)
# ================================================================

# Tests unitaires avec couverture
unit_tests:
  stage: test
  <<: *install_dependencies
  script:
    - source venv/bin/activate
    - pytest tests/unit/ -v --cov=app --cov-report=xml --cov-report=html --cov-report=term
    - echo "‚úÖ Unit tests passed"
  coverage: '/(?i)total.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'
  artifacts:
    reports:
      junit: junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - htmlcov/
      - coverage.xml
    expire_in: 1 week
  allow_failure: false

# Tests E2E (End-to-End)
e2e_tests:
  stage: test
  image: python:3.11-slim
  services:
    - name: python:3.11-slim
      alias: api
  <<: *install_dependencies
  variables:
    GEMINI_API_KEY: $GEMINI_API_KEY_TEST
    FLASK_ENV: testing
  script:
    - source venv/bin/activate
    # D√©marrer l'API en arri√®re-plan
    - python -m app.main &
    - sleep 5
    # Ex√©cuter les tests E2E
    - pytest tests/e2e/ -v --html=e2e-report.html --self-contained-html
    - echo "‚úÖ E2E tests passed"
  artifacts:
    paths:
      - e2e-report.html
    expire_in: 1 week
  allow_failure: false
  only:
    - main
    - develop
    - merge_requests

# ================================================================
# STAGE 3: BUILD (Docker Image)
# ================================================================

build_docker_image:
  stage: build
  image: docker:24-alpine
  services:
    - docker:24-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - echo "üî® Building Docker image..."
    - |
      docker build \
        --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
        --build-arg VCS_REF=$CI_COMMIT_SHORT_SHA \
        --build-arg VERSION=$CI_COMMIT_TAG \
        -t $IMAGE_NAME:$IMAGE_TAG \
        -t $IMAGE_NAME:latest \
        .
    - echo "üì§ Pushing Docker image to GitLab Registry..."
    - docker push $IMAGE_NAME:$IMAGE_TAG
    - docker push $IMAGE_NAME:latest
    - echo "‚úÖ Docker image built and pushed successfully"
    - echo "IMAGE_NAME=$IMAGE_NAME" >> build.env
    - echo "IMAGE_TAG=$IMAGE_TAG" >> build.env
  artifacts:
    reports:
      dotenv: build.env
  only:
    - main
    - develop
    - tags

# Scan de s√©curit√© de l'image Docker avec Trivy
docker_security_scan:
  stage: build
  image: aquasec/trivy:latest
  dependencies:
    - build_docker_image
  script:
    - trivy image --format json --output trivy-report.json $IMAGE_NAME:$IMAGE_TAG
    - trivy image --severity HIGH,CRITICAL --exit-code 0 $IMAGE_NAME:$IMAGE_TAG
    - echo "‚úÖ Docker security scan completed"
  artifacts:
    paths:
      - trivy-report.json
    expire_in: 1 week
  allow_failure: true
  only:
    - main
    - develop
    - tags

# ================================================================
# STAGE 4: RELEASE (Tag + Release + Image tagu√©e)
# ================================================================

create_release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  dependencies:
    - build_docker_image
  script:
    - echo "üì¶ Creating GitLab release..."
    - |
      release-cli create \
        --name "Release $CI_COMMIT_TAG" \
        --tag-name $CI_COMMIT_TAG \
        --description "$(cat .gitlab/release-template.md)" \
        --assets-link "{\"name\":\"Docker Image\",\"url\":\"$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG\",\"link_type\":\"image\"}" \
        --assets-link "{\"name\":\"Coverage Report\",\"url\":\"$CI_PROJECT_URL/-/jobs/artifacts/$CI_COMMIT_TAG/file/htmlcov/index.html\",\"link_type\":\"other\"}"
  only:
    - tags
  when: manual

# Tag de l'image Docker avec le tag Git
tag_docker_image:
  stage: release
  image: docker:24-alpine
  services:
    - docker:24-dind
  dependencies:
    - build_docker_image
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - echo "üè∑Ô∏è Tagging Docker image with Git tag..."
    - docker pull $IMAGE_NAME:$IMAGE_TAG
    - docker tag $IMAGE_NAME:$IMAGE_TAG $IMAGE_NAME:$CI_COMMIT_TAG
    - docker push $IMAGE_NAME:$CI_COMMIT_TAG
    - echo "‚úÖ Docker image tagged with $CI_COMMIT_TAG"
  only:
    - tags

# Release automatique sur la branche main
auto_release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  dependencies:
    - build_docker_image
  script:
    - TIMESTAMP=$(date +%Y%m%d-%H%M%S)
    - AUTO_TAG="v1.0.0-$TIMESTAMP"
    - echo "Creating automatic release $AUTO_TAG"
  only:
    - main
  when: manual
